# 本篇中的名词都是作者基于自己理解做出的解释，非权威解释。
如果你找到权威解释，欢迎pr。

# 游戏服务器中那些被神话了的歧义的名词
关于游戏服务器架构的很多文章总是忽略或者误用某些名词，有意无意的掩盖了服务器设计中的真实细节，类似于数学教科书答案中的`显然` `易得`。个人理解，有不对的地方请指正。
1. `广播` 区别于UDP广播报，真实网络中协议层的广播报基本都被运营商和路由器等各个环节屏蔽了。服务器的广播实现就是把字节数组消息逐个发送给每个客户端连接，性能取决于代码，基本上都是异步广播方法+消息队列。
2. `转发` 多用于服务器之间。都是应用层转发，没有任何技术含量，接收->反序列化->确定转发目标->序列化->网络层发送。一些高性能的转发也仅仅是通过解析报头确定转发目标，省去反序列序列化的消耗。转发会产生一定量的服务器开销和延时。以致于我一度怀疑网关服务器存在的意义。
3. `buffer` 缓冲区，网络层中个人认为最开始指系统中socket和系统内核数据交换的地方（猜测，没有任何证据）。实际上交流中凡是`byte[]字节数组` 都有可能被叫做buffer，具体含义十分模糊，你可能永远不知道对方说的是啥。

# 经典网络层中的名词：
## SendBuffer/Sbuffer/用户态发送缓冲区
指用户态的要发送的字节数组：
- int Send(byte[] buffer, int size, SocketFlags socketFlags)中的buffer
- SocketAsyncEventArgs 中的 byte[] Buffer { get; }
应用程序将要发送的内容变成一个字节数组，通过socket.send函数发送，这个内存块就是用户态发送缓冲区。

## RecvBuffer/Rbuffer/用户态接收缓冲区
与发送对应，只用户态的一个字节数组，可以是new 的也可是从内存池申请的，通过recv函数接收。注意用于接收过程中的SocketAsyncEventArgs的Buffer，可以看作用户态接收缓冲区。

## Socket SendBufferSize ReceiveBufferSize
指的socket内核缓冲区，或者说内核滑动窗口大小。
Socket 发送 SendBuffer 1024大小，将SendBuffer复制到内核缓冲区（默认8192），这时Send函数就可以返回了，系统负责将内核缓冲区的数据发送到 远端的接收内核缓冲区，远端调用Recv函数，将接收内核缓冲区的数据拷贝到RecvBuffer。
- 如何远端没有接收 内核发送缓冲区会一直累积，当累计满了，比如内核发送缓冲区大小8192，有8000字节对面没有接收，Socket继续Send SendBuffer 1024，由于内核发送缓冲区已经没有容量了，那么这次Send函数就会阻塞，卡住，直到对面接收。

## 序列化/反序列化 缓冲区
用于将对象转换成字节用的 字节数组，也有memorystream的形式。

# 完整发送过程
发送object--序列化/将obj变成字节数组这个字节数组就是序列化缓冲区--拷贝到SendBuffer--Socket Send/拷贝到内核缓冲区--网线--接收内核缓冲区--Socket Recv/拷贝到RecvBuffer--反序列化/拷贝到反序列化缓冲区--收到object。


# 本库中的名词
本库高度优化了上述发送过程，上述流程不能与本库代码对应。
## S区/SArea
可能是一段连续内存，也肯能是一系列内存片段，是object消息经过序列化后的东西，正在等待Socket发送的，这些东西的有序容器。
## R区/RArea
接收到的字节内容，经过分离粘包处理后，一个个代表完整包的字节数组或片段，此时还没有开始反序列化。保存这些内容的区域称为R区。

# 参考链接
[TCP的发送缓冲区和接收缓冲区](https://www.cnblogs.com/saryli/p/9821058.html)

